//=================================================================================================
//
//   In questro file si effettua la lettura di alcuni topic
//
//=================================================================================================
#include "ros/ros.h"
#include "std_msgs/String.h"
#include <iostream>

#include <errno.h>
#include <termios.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <termios.h>
#include <strings.h>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <iostream>
#include <queue>
#include  <sys/time.h>
//numero di Header che deve avere il pacchetto che ricevo
#define HEADER_BYTES  2

//numero di interi (32 bit) che ha il pacchetto che ricevo (52 +1 terminatore)
#define PAYLOAD_NBYTES   53
  

//++++++++++++++++++++
int start = 0;
std::string str;
float PI = 3.14159;
using std::cout;
using std::endl;

timeval start_, stop_;
double elsapsed_time;
//++++++++++++++++++++

int
set_interface_attribs (int fd, int speed, int parity)
{
        struct termios tty;
        memset (&tty, 0, sizeof tty);
        if (tcgetattr (fd, &tty) != 0)
        {
		printf("error %d from tcgetattr", errno) ;              
		//error_message("error %d from tcgetattr", errno);
                return -1;
        }

        cfsetospeed (&tty, speed);
        cfsetispeed (&tty, speed);

        tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8;     // 8-bit chars
        // disable IGNBRK for mismatched speed tests; otherwise receive break
        // as \000 chars
        tty.c_iflag &= ~IGNBRK;         // disable break processing
        tty.c_lflag = 0;                // no signaling chars, no echo,
                                        // no canonical processing
        tty.c_oflag = 0;                // no remapping, no delays
        tty.c_cc[VMIN]  = 0;            // read doesn't block
        tty.c_cc[VTIME] = 5;            // 0.5 seconds read timeout

        tty.c_iflag &= ~(IXON | IXOFF | IXANY); // shut off xon/xoff ctrl

        tty.c_cflag |= (CLOCAL | CREAD);// ignore modem controls,
                                        // enable reading
        tty.c_cflag &= ~(PARENB | PARODD);      // shut off parity
        tty.c_cflag |= parity;
        tty.c_cflag &= ~CSTOPB;
        tty.c_cflag &= ~CRTSCTS;

        if (tcsetattr (fd, TCSANOW, &tty) != 0)
        {
                printf("error %d from tcsetattr", errno);
                return -1;
        }
        return 0;
}

void
set_blocking (int fd, int should_block)
{
        struct termios tty;
        memset (&tty, 0, sizeof tty);
        if (tcgetattr (fd, &tty) != 0)
        {
                printf("error %d from tggetattr", errno);
                return;
        }

        tty.c_cc[VMIN]  = should_block ? 1 : 0;
        tty.c_cc[VTIME] = 5;            // 0.5 seconds read timeout

        if (tcsetattr (fd, TCSANOW, &tty) != 0)
                printf("error %d setting term attributes", errno);
}
/*****************************************************************/
/*                                                               */
/*                 DECODE PACKE                                  */
/*****************************************************************/
void decode_packet(std::queue<unsigned char> coda_seriale, float* roll,float* pitch,float* yaw,float* acc_x,float* acc_y,float* acc_z,float* w_x,float* w_y,float* w_z,float* mag_x,float* mag_y,float* mag_z)
{

 int decode;
        decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *roll = (float)decode / 1000 * 180 /PI;

        ////////////////////////////////////////////
        decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *pitch = (float)decode / 1000 * 180 /PI;
        /////////////////////////////////////////////////
        decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *yaw = (float)decode / 1000 * 180 /PI;

        /////////////////////////////////////////////////////
         decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *acc_x = (float)decode / 1000 ;

        ////////////////////////////////////////////
        decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *acc_y = (float)decode / 1000 ;
        /////////////////////////////////////////////////
        decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *acc_z = (float)decode / 1000;
        
        /////////////////////////////////////////////////////
         decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *w_x = (float)decode / 1000 ;

        ////////////////////////////////////////////
        decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *w_y = (float)decode / 1000 ;
        /////////////////////////////////////////////////
        decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *w_z = (float)decode / 1000;
           /////////////////////////////////////////////////////
         decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *mag_x = (float)decode / 1000 ;

        ////////////////////////////////////////////
        decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *mag_y = (float)decode / 1000 ;
        /////////////////////////////////////////////////
        decode = (long int)coda_seriale.front();
        coda_seriale.pop();
        decode = decode | (0x0000FF00 &(((long int)coda_seriale.front())<<8));
        coda_seriale.pop();
        decode = decode | (0x00FF0000 &(((long int)coda_seriale.front())<<16));
        coda_seriale.pop();
        decode = decode | (0xFF000000 &(((long int)coda_seriale.front())<<24));
        coda_seriale.pop();
        
        *mag_z = (float)decode / 1000;

	       
        //Svuoto gli ultimi 4 byte
        coda_seriale.pop();
        coda_seriale.pop();
        coda_seriale.pop();
        coda_seriale.pop();



}


int main(int argc, char **argv)
{
  /**
   * The ros::init() function needs to see argc and argv so that it can perform
   * any ROS arguments and name remapping that were provided at the command line.
   * For programmatic remappings you can use a different version of init() which takes
   * remappings directly, but for most command-line programs, passing argc and argv is
   * the easiest way to do it.  The third argument to init() is the name of the node.
   *
   * You must call one of the versions of ros::init() before using any other
   * part of the ROS system.
  */
  ros::init(argc, argv, "ros_serial");

  /**
   * NodeHandle is the main access point to communications with the ROS system.
   * The first NodeHandle constructed will fully initialize this node, and the last
   * NodeHandle destructed will close down the node.
   */


std::queue<unsigned char> coda_seriale;

const char * portname = "/dev/ttyUSB0";

int fd = open(portname, O_RDWR | O_NOCTTY | O_SYNC);
if (fd < 0)
{
        printf("error %d opening %s: %s", errno, portname, strerror (errno));
        return -1;
}

set_interface_attribs (fd, B115200, 0);  // set speed to 115,200 bps, 8n1 (no parity)
set_blocking (fd, 0);




  ros::NodeHandle n;
//  ros::Rate loop_rate(100); // 100 Hz
 while(ros::ok())
	{




//loop_rate.sleep()
	}

  return 0;
}
